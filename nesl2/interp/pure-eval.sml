(* pure-eval.sml
 *
 * COPYRIGHT (c) 2014 John Reppy (http://cs.uchicago.edu/~jhr)
 * All rights reserved.
 *)

structure PureEval =
  struct

    structure P = Pure
    structure V = Value
    structure TB = TypeBase

    fun evalPure (rator, args) = (case args
	   of (P.ADD TB.INT, [V.I a, V.I b]) => V.I(a+b)
	    | (P.ADD TB.FLOAT, [V.F a, V.F b]) => V.F(a+b)
	    | (P.SUB TB.INT, [V.I a, V.I b]) => V.I(a-b)
	    | (P.SUB TB.FLOAT, [V.F a, V.F b]) => V.F(a-b)
	    | (P.MUL TB.INT, [V.I a, V.I b]) => V.I(a*b)
	    | (P.MUL TB.FLOAT, [V.F a, V.F b]) => V.F(a*b)
	    | (P.DIV TB.INT, [V.I a, V.I b]) => V.I(a div b)  (* should this be Int.quot? *)
	    | (P.DIV TB.FLOAT, [V.F a, V.F b]) => V.F(a/b)
	    | (P.MOD, [V.I a, V.I b]) => V.I(a mod b)  (* should this be Int.rem? *)
	    | (P.LT TB.INT, [V.I a, V.I b]) => V.B(a < b)
	    | (P.LT TB.FLOAT, [V.F a, V.F b]) => V.B(a < b)
	    | (P.LTE TB.INT, [V.I a, V.I b]) => V.B(a <= b)
	    | (P.LTE TB.FLOAT, [V.F a, V.F b]) => V.B(a <= b)
	    | (P.GT TB.INT, [V.I a, V.I b]) => V.B(a > b)
	    | (P.GT TB.FLOAT, [V.F a, V.F b]) => V.B(a > b)
	    | (P.GTE TB.INT, [V.I a, V.I b]) => V.B(a >= b)
	    | (P.GTE TB.FLOAT, [V.F a, V.F b]) => V.B(a >= b)
	    | (P.EQ TB.INT, [V.I a, V.I b]) => V.B(a = b)
	    | (P.EQ TB.FLOAT, [V.F a, V.F b]) => V.B(Real.==(a, b))
	    | (P.EQ TB.INT, [V.I a, V.I b]) => V.B(a <> b)
	    | (P.EQ TB.FLOAT, [V.F a, V.F b]) => V.B(Real.!=(a, b))

	    | P.LSHIFT		        (* LSHIFT *)
	    | P.RSHIFT		        (* RSHIFT *)
	    | P.NOT of ty               (* NOT {BOOL, INT} *)
	    | P.AND of ty               (* AND {BOOL, INT} *)
	    | P.OR of ty                (* OR {BOOL, INT} *)
	    | P.XOR of ty               (* XOR {BOOL, INT} *)
	    | P.SELECT of ty            (* SELECT {INT, BOOL, FLOAT} *)
	    | P.RAND                    (* RAND *)
	    | P.FLOOR                   (* FLOOR *)
	    | P.CEIL                    (* CEIL *)
	    | P.TRUNC                   (* TRUNC *)
	    | P.ROUND                   (* ROUND *)
	    | P.I_TO_F                  (* I_TO_F *)
	    | P.I_TO_B                  (* I_TO_B *)
	    | P.B_TO_I                  (* B_TO_I *)
	    | P.LOG		        (* LOG *)
	    | P.SQRT		        (* SQRT *)
	    | P.EXP		        (* EXP *)
	    | P.SIN		        (* SIN *)
	    | P.COS		        (* COS *)
	    | P.TAN		        (* TAN *)
	    | P.ASIN		        (* ASIN *)
	    | P.ACOS		        (* ACOS *)
	    | P.ATAN		        (* ATAN *)
	    | P.SINH		        (* SINH *)
	    | P.COSH		        (* COSH *)
	    | P.TANH		        (* TANH *)
	    | P.I_TO_C			(* I_TO_C *)
	    | P.C_TO_I			(* C_TO_I *)
	  (* Vector instructions *)
	    | P.ADD_SCAN of ty          (* +_SCAN {INT, FLOAT} *)
	    | P.MUL_SCAN of ty          (* *_SCAN {INT, FLOAT} *)
	    | P.MAX_SCAN of ty          (* MAX_SCAN {INT, FLOAT} *)
	    | P.MIN_SCAN of ty          (* MIN_SCAN {INT, FLOAT} *)
	    | P.AND_SCAN of ty          (* AND_SCAN {INT, BOOL} *)
	    | P.OR_SCAN of ty           (* OR_SCAN {INT, BOOL} *)
	    | P.XOR_SCAN of ty          (* XOR_SCAN {INT, BOOL} *)
	    | P.ADD_REDUCE of ty        (* +_REDUCE {INT, FLOAT} *)
	    | P.MUL_REDUCE of ty        (* *_REDUCE {INT, FLOAT} *)
	    | P.MAX_REDUCE of ty        (* MAX_REDUCE {INT, FLOAT} *)
	    | P.MIN_REDUCE of ty        (* MIN_REDUCE {INT, FLOAT} *)
	    | P.AND_REDUCE of ty        (* AND_REDUCE {INT, BOOL} *)
	    | P.OR_REDUCE of ty         (* OR_REDUCE {INT, BOOL} *)
	    | P.XOR_REDUCE of ty        (* XOR_REDUCE {INT, BOOL} *)
	    | P.PERMUTE of ty		(* PERMUTE {INT, BOOL, FLOAT} *)
	    | P.DPERMUTE of ty		(* DPERMUTE {INT, BOOL, FLOAT} *)
	    | P.FPERMUTE of ty		(* FPERMUTE {INT, BOOL, FLOAT} *)
	    | P.BPERMUTE of ty		(* BPERMUTE {INT, BOOL, FLOAT} *)
	    | P.BFPERMUTE of ty		(* BFPERMUTE {INT, BOOL, FLOAT} *)
	    | P.DFPERMUTE of ty		(* DFPERMUTE {INT, BOOL, FLOAT} *)
	    | P.EXTRACT of ty		(* EXTRACT {INT, BOOL, FLOAT} *)
	    | P.REPLACE of ty		(* REPLACE {INT, BOOL, FLOAT} *)
	    | P.PACK of ty		(* PACK {INT, BOOL, FLOAT} *)
	    | P.RANK_UP of ty		(* RANK_UP {INT, FLOAT} *)
	    | P.RANK_DOWN of ty		(* RANK_DOWN {INT, FLOAT} *)
(* what about segment descriptors? *)
	    | (P.DIST TB.INT, [value as V.I _, V.I len]) => V.Seq(Vector.tabulate(len, fn _ => value))
	    | (P.DIST TB.BOOL, [value as V.B _, V.I len]) => V.Seq(Vector.tabulate(len, fn _ => value))
	    | (P.DIST TB.FLOAT, [value as V.F _, V.I len]) => V.Seq(Vector.tabulate(len, fn _ => value))
	    | P.INDEX		        (* INDEX *)
	    | P.LENGTH of ty		(* LENGTH {INT, BOOL, FLOAT} *)
	  (* Segment descriptor instructions *)
	    | P.MAKE_SEGDES		(* MAKE_SEGDES *)
	    | P.LENGTHS		        (* LENGTHS *)
	  (* additional instructions *)
	    | P.PROJ of int		(* PROJ i -- project i'th component of tuple (first = 1, ...) *)
	    | P.SCALAR_TO_SEQ of ty	(* SCALAR_TO_SEQ {INT, BOOL, FLOAT, CHAR} -- create singleton base sequence *)
	    | P.SEQ_TO_SCALAR of ty	(* SEQ_TO_SCALAR {INT, BOOL, FLOAT, CHAR} -- extract value from singleton base sequence *)
	    | _ => raise Fail "operator/argument mismatch"
	  (* end case *))

    fun eval (FlanPure.Lifted rator, args) = (case args
	   of [V.Seq v] => V.Seq(Vector.map (fn x => evalPure(rator, [x])) v)
	    | [V.Seq v1, V.Seq v2] =>
		if (Vector.length v1 <> Vector.length v2)
		  then raise Fail "length mismatch"
		  else V.Seq(Vector.tabulate(Vector.length v1, fn i => evalPure(rator, [Vector.sub(v1, i), Vector.sub(v2, i)])))
	    | _ => raise Fail "too many arguments to lifted operator"
	  (* end case *))
      | eval (FlanPure.Base rator, args) = evalPure (rator, args)

  end
